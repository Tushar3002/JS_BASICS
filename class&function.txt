///////////////////////////////////////////////////////////////////////////////////////////////////
CLASS

The constructor() method is a special method for creating and initializing objects created within a class.
The constructor() method is called automatically when a class is initiated, and it has to have the exact name "constructor", 
in fact, if you do not have a constructor method, JavaScript will add an invisible and empty constructor method.

Note: A class cannot have more than one constructor() method. This will throw a SyntaxError.

class Car {
  constructor(brand) {  // Constructor
    this.carname = brand;
  }
}
mycar = new Car("Ford");

----------------------------------

class Car {
  constructor(brand) {
    this.carname = brand;
  }
  present() {
    return 'I have a ' + this.carname;
  }
}

class Model extends Car {
  constructor(brand, mod) {
    super(brand);
    this.model = mod;
  }
  show() {
    return this.present() + ', it is a ' + this.model;
  }
}

mycar = new Model("Ford", "Mustang");
document.getElementById("demo").innerHTML = mycar.show();

/////////////////
The static keyword defines static methods for classes.
Static methods are called directly on the class (Car from the example above) - without creating an instance/object (mycar) of the class.

class Car {
  constructor(brand) {
    this.carname = brand;
  }
  static hello() {  // static method
    return "Hello!!";
  }
}

mycar = new Car("Ford");

//Call 'hello()' on the class Car:
document.getElementById("demo").innerHTML = Car.hello();

//and NOT on the 'mycar' object:
//document.getElementById("demo").innerHTML = mycar.hello();
//this would raise an error.

///////////////
The super keyword is used to call the constructor of its parent class to access the parent's properties and methods.

--------------------------------------------DATES

const time = new Date();

const d = new Date();
let day = d.getDate();

---------------------------------------------Function

The Difference Between call() and apply()
The call() method takes arguments separately.

The apply() method takes arguments as an array.
The apply() method calls a function with a given this value.
The apply() method lets objects borrow methods from other objects.
With the apply() method, you can write a method that can be used on different objects.

// Create a person Object
const person = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}

// Create a person1 Object
const person1 = {
  firstName:"John",
  lastName: "Doe"
}

// Apply the fulllName method of person to person1:
let name = person.fullName.apply(person1); 

////////////////////////////

The Difference Between bind() and apply()
The difference between bind() and apply() lies in their immediate execution and return value:

apply()
Immediately invokes (calls) the function it is called on
Passes arguments as an array

bind()
Returns the the function it is called on
Passes arguments individually

Use Cases
Use apply() when you want to immediately execute a function with a specific this context and you have the arguments ready in an array.

Use bind() when you want to create a new function with a permanently bound this context and potentially some pre-set arguments) for 
later execution or use as a callback.

function fullName() {
  document.getElementById("demo").innerHTML = this.fName + " " + this.lName;
}

// Create a person Object
const person = {
  fName: "John",
  lName: "Doe"
}

// Use fullName on person
let name = fullName.bind(person); 
name();

//////////////////////

The call() method calls a function with a given this value.

The call() method lets objects borrow methods from other objects.

function fullName() {
  return this.fName + " " + this.lName;
}

// Create a person Object
const person = {
  fName: "John",
  lName: "Doe"
}

// Use fullName on person
let name = fullName.call(person); 

The Difference Between call() and apply() 
The call() method takes arguments separately. 

The apply() method takes arguments as an array.

///////////////////

function fn1() {};
function fn2(a, b, c) {};

// Get Function names
let text = fn1.name + " " + fn2.name;  //to get the function name


function myFunction() {
  return "Hello";
}

let text = myFunction.toString();    //function myFunction() { return "Hello"; }

//////////////////////

Key Differences (Quick Table)
Feature	              call	    apply	    bind
Invokes immediately	  ✅	        ✅  	    ❌
Returns a function	  ❌	        ❌	      ✅
Arguments style	 Comma-separated	Array	  Comma-separated
this binding	     Temporary	 Temporary	  Permanent


When to Use What?

✅ call – When arguments are known and passed individually

✅ apply – When arguments are in an array (e.g., Math.max)

✅ bind – When you want to reuse a function later with fixed this


In JavaScript, call, apply, and bind are methods used to control what this refers to when a function is executed.

1. call()

Invokes the function immediately, with a specified this value and arguments passed individually.

Syntax
func.call(thisArg, arg1, arg2, ...)


Example
function greet(greeting, punctuation) {
  console.log(greeting + " " + this.name + punctuation);
}

const user = { name: "Alice" };

greet.call(user, "Hello", "!");
// Hello Alice!

2. apply()

Invokes the function immediately, with a specified this value and arguments passed as an array.

Syntax
func.apply(thisArg, [arg1, arg2, ...])

Example
greet.apply(user, ["Hi", "?"]);
// Hi Alice?


3. bind()

Does NOT invoke the function immediately.
Instead, it returns a new function with this permanently bound.

Syntax
const boundFunc = func.bind(thisArg, arg1, arg2, ...)

Example
const boundGreet = greet.bind(user, "Hey");
boundGreet("!!");
// Hey Alice!!


All these methods are user for method/functions borrowing/sharing.
1. call method is used to call the function with the given this value and argument can be passed individually.
2. apply method is similar to call method, the only difference is that instead of passing argument individually, will pass the argument in a list/array.
3. bind method is similar to call method. It is also used to override this value, but the difference is it will not invoke the function instantly but return a function with attached this and argument which can be called later.


call()-------------------------------------

let name1={
    firstname : "TJ",
    city:"Rajkot",
    printInfo:function(city){
        console.log(this.firstname,this.city,city)
    }

}

name1.printInfo()// TJ Rajkot undefined


let name2={
    firstname:"Tushar"
}

name1.printInfo.call(name2,"OSaka")//Tushar undefined OSaka




------------------ORRRRRRRRRRRRRRRRRRRRRRRRR-----------------

let name1={
    firstname : "TJ",
    city:"Rajkot",
    
}

function printInfo(city){
        console.log(this.firstname,this.city,city)
    }


printInfo("raj") ///undefined undefined 'raj'
printInfo.call(name1,"raj") //TJ Rajkot raj


let name2={
    firstname:"Tushar"
}

printInfo.call(name2,"OSaka")  ///Tushar undefined OSaka


---------------------------apply

function printInfo(city,state){
        console.log(this.firstname,this.city,city,state)
    }


let name2={
    firstname:"Tushar"
}

printInfo.call(name2,"OSaka","GUJ") //Tushar undefined OSaka GUJ

printInfo.apply(name2,["OSaka","GUJ"]) //Tushar undefined OSaka GUJ

//-----------------BIND

let printMyName = printInfo.bind(name1,"Rajkot")
console.log(printMyName);

printMyName()
