WeakMap / WeakSet hold objects weakly â€” if nothing else references an object, JS can garbage-collect it even 
if itâ€™s inside a WeakMap/WeakSet.

Why normal Map / Set can be dangerous
const map = new Map();

let user = { name: "A" };
map.set(user, "online");

user = null; // you think it's goneâ€¦


âŒ Nope.
map still holds a strong reference, so the object stays in memory forever.

Memory leak â˜ ï¸

Enter WeakMap ğŸ¦¸
const wm = new WeakMap();

let user = { name: "A" };
wm.set(user, "online");

user = null; // object can now be GC'd


âœ… When the object is unreachable elsewhere, itâ€™s automatically removed from WeakMap.

You donâ€™t control when â€” the GC decides.

WeakMap in Detail
Rules (very important)
Rule	                    Explanation
Keys must be objects	    âŒ no strings, numbers
Values can be anything	    objects, primitives, functions
Not iterable	            âŒ no .keys(), .values(), forEach
No .size	                JS canâ€™t know (GC is nondeterministic)


Example: Private data (classic use case)
const privateData = new WeakMap();

class User {
  constructor(name, password) {
    this.name = name;
    privateData.set(this, { password });
  }

  checkPassword(pw) {
    return privateData.get(this).password === pw;
  }
}

Why WeakMap is perfect here

Data is truly private
When User instance is gone â†’ private data is gone
No memory leaks
No naming collisions


WeakMap vs Map (clear comparison)
Feature	                    Map	                WeakMap
Key types	                Any	                Objects only
Iterable	                âœ…	                  âŒ
.size	                    âœ…	                  âŒ
GC friendly	                âŒ	                  âœ…
Use for data ownership	    âœ…	                  âŒ
Use for metadata	        âŒ	                  âœ…

WeakSet vs Set
Feature	                    Set	                    WeakSet
Stores primitives	        âœ…	                    âŒ
Iterable	                âœ…	                    âŒ
Prevents memory leaks	    âŒ	                    âœ…
Best use	            collections	            markers / flags




â“ Why no iteration?

Because the JS engine can remove entries at any time due to GC.
Iteration would be unreliable and misleading.

â“ Why only objects as keys?

Because only objects are garbage-collectable by reference.
Primitives live on the stack / interned â€” no GC semantics.

â“ When should I NOT use WeakMap?

You need to list entries

You need .size

You want long-term storage
â†’ Use Map

Mental Model (remember this)

Map / Set own their data
WeakMap / WeakSet only observe objects

If the object dies, the weak structure forgets it ever existed.