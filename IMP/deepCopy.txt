const original = { name: 'Bob', details: { age: 28 } };
const deepCopy = JSON.parse(JSON.stringify(original));

-----------------------------------------------------
ðŸ”¹ Step 1: JSON.stringify(original)
JavaScript converts the object into a JSON string.

JSON.stringify(original)

Internally:
Reads each property of original
Converts it into a JSON-compatible format
Recursively processes nested objects

Result:

'{"name":"Bob","details":{"age":28}}'

ðŸ“Œ At this point:
This is just plain text
No object references exist anymore
Memory links are completely broken

ðŸ”¹ Step 2: JSON.parse(...)

JSON.parse('{"name":"Bob","details":{"age":28}}')

Internally:
Reads the JSON string
Creates a brand new object in memory
Creates new nested objects as well

Result:

{
  name: "Bob",
  details: {
    age: 28
  }
}
ðŸ”¹ Step 3: Reference comparison

original === deepCopy;           // false
original.details === deepCopy.details; // false
âœ” Different memory locations
âœ” No shared references

Thatâ€™s why modifying the copy doesnâ€™t affect the original:

deepCopy.details.age = 30;

console.log(original.details.age); // 28

ðŸ”¹ Visual memory model ðŸ§ 
Before copy:

original â”€â”€â–¶ { name, details â”€â”€â–¶ { age } }

After copy:

original â”€â”€â–¶ { name, details â”€â”€â–¶ { age } }
deepCopy â”€â”€â–¶ { name, details â”€â”€â–¶ { age } }

âœ” Completely separate object trees

âš ï¸ What happens to unsupported values
During JSON.stringify:

Value	                  Result
undefined	              removed
function	              removed
Date	                  converted to string
Symbol	                removed
Circular reference	    âŒ error

Example:

JSON.stringify({ a: undefined, b: () => {} })
// "{}"

ðŸ”‘ Final summary
Serialize object â†’ JSON string
Deserialize string â†’ new object
All references broken
Works only for JSON-safe data